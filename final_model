import keras
import tensorflow as tf
from keras.models import Sequential

from keras.layers.core import Dense, Dropout

from keras.layers.convolutional import Convolution3D, MaxPooling3D, ZeroPadding3D

from keras.optimizers import SGD



def get_model(summary=False):

    """ Return the Keras model of the network

    """

    model = Sequential()

    # 1st layer group

    model.add(Convolution3D(64, 3, 3, 3, activation='relu', 

                            border_mode='same', name='conv1',

                            subsample=(1, 1, 1), 

                            input_shape=(3, 16, 112, 112)))

    model.add(MaxPooling3D(pool_size=(1, 2, 2), strides=(1, 2, 2), 

                           border_mode='valid', name='pool1'))

    # 2nd layer group

    model.add(Convolution3D(128, 3, 3, 3, activation='relu', 

                            border_mode='same', name='conv2',

                            subsample=(1, 1, 1)))

    model.add(MaxPooling3D(pool_size=(2, 2, 2), strides=(2, 2, 2), 

                           border_mode='valid', name='pool2'))

    # 3rd layer group

    model.add(Convolution3D(256, 3, 3, 3, activation='relu', 

                            border_mode='same', name='conv3a',

                            subsample=(1, 1, 1)))

    model.add(Convolution3D(256, 3, 3, 3, activation='relu', 

                            border_mode='same', name='conv3b',

                            subsample=(1, 1, 1)))

    model.add(MaxPooling3D(pool_size=(2, 2, 2), strides=(2, 2, 2), 

                           border_mode='valid', name='pool3'))

    # 4th layer group

    model.add(Convolution3D(512, 3, 3, 3, activation='relu', 

                            border_mode='same', name='conv4a',

                            subsample=(1, 1, 1)))

    model.add(Convolution3D(512, 3, 3, 3, activation='relu', 

                            border_mode='same', name='conv4b',

                            subsample=(1, 1, 1)))

    model.add(MaxPooling3D(pool_size=(2, 2, 2), strides=(2, 2, 2), 

                           border_mode='valid', name='pool4'))

    # 5th layer group

    model.add(Convolution3D(512, 3, 3, 3, activation='relu', 

                            border_mode='same', name='conv5a',

                            subsample=(1, 1, 1)))

    model.add(Convolution3D(512, 3, 3, 3, activation='relu', 

                            border_mode='same', name='conv5b',

                            subsample=(1, 1, 1)))

   

    model.add(MaxPooling3D(pool_size=(2, 1, 1), strides=(2, 1, 1), 

                           border_mode='valid', name='pool5'))



    if summary:

        print(model.summary())

    return model



model = get_model(summary=True)



import caffe_pb2 as caffe



import numpy as np







p = caffe.NetParameter()



p.ParseFromString(



    open('conv3d_deepnetA_sport1m_iter_1900000', 'rb').read()



)







def rot90(W):



    for i in range(W.shape[0]):



        for j in range(W.shape[1]):



            for k in range(W.shape[2]):



                W[i, j, k] = np.rot90(W[i, j, k], 2)



    return W







params = []



conv_layers_indx = [1, 4, 7, 9, 12, 14, 17, 19]



fc_layers_indx = [22, 25, 28]







for i in conv_layers_indx:



    layer = p.layers[i]



    weights_b = np.array(layer.blobs[1].data, dtype=np.float32)



    weights_p = np.array(layer.blobs[0].data, dtype=np.float32).reshape(



        layer.blobs[0].num, layer.blobs[0].channels, layer.blobs[0].length,



        layer.blobs[0].height, layer.blobs[0].width



    )



    weights_p = rot90(weights_p)



    params.append([weights_p, weights_b])



for i in fc_layers_indx:



    layer = p.layers[i]



    weights_b = np.array(layer.blobs[1].data, dtype=np.float32)



    weights_p = np.array(layer.blobs[0].data, dtype=np.float32).reshape(



        layer.blobs[0].num, layer.blobs[0].channels, layer.blobs[0].length,



        layer.blobs[0].height, layer.blobs[0].width)[0,0,0,:,:].T



    params.append([weights_p, weights_b])



    



model_layers_indx = [0, 2, 4, 5, 7, 8, 10, 11]  #conv 



for i, j in zip(model_layers_indx, range(11)):



    model.layers[i].set_weights(params[j])



 



import h5py







model.save_weights('sports1M_weights.h5', overwrite=True)



json_string = model.to_json()



with open('sports1M_model.json', 'w') as f:



    f.write(json_string)
    
from keras.models import model_from_json

model = model_from_json(open('sports1M_model.json', 'r').read())
model.load_weights('sports1M_weights.h5')
model.compile(loss='mean_squared_error', optimizer='sgd')
model.add(tf.keras.layers.LSTM(2048, 
          return_sequences=False,           
          input_shape=input_shape,             
          dropout=0.5)) 
model.add(tf.keras.layers.Dense(512, activation='relu')) 
model.add(tf.keras.layers.Dropout(0.5)) 
model.add(tf.keras.layers.Dense(no_classes, activation='softmax')) 
print(model)

with open('dataset/labels.txt', 'r') as f:
    labels = [line.strip() for line in f.readlines()]
print('Total labels: {}'.format(len(labels)))

model = get_model(summary=True)
import cv2
import numpy as np

cap = cv2.VideoCapture('dM06AMFLsrc.mp4')

vid = []
while True:
    ret, img = cap.read()
    if not ret:
        break
    vid.append(cv2.resize(img, (171, 128)))
vid = np.array(vid, dtype=np.float32)

X = vid[2000:2016, 8:120, 30:142, :].transpose((3, 0, 1, 2))
output = model.predict_on_batch(np.array([X]))

print('Position of maximum probability: {}'.format(output[0].argmax()))
print('Maximum probability: {:.5f}'.format(max(output[0][0])))
print('Corresponding label: {}'.format(labels[output[0].argmax()]))


